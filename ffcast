#!/bin/bash
###::: take screencast using ffmpeg with the help of xwininfo
# Original: http://bbs.archlinux.org/viewtopic.php?id=85237
#           http://continuity.intelink.pl/~neuro/projects/lossless_screencast.sh
# Original Author: Copyright (c) Michal Witkowski 2009
# License: GPL v3
# Modified by: lolilolicon (and he likes to call it ffcast)
# lolilolicon <lolilolicon@gmail.com>
# git clone git://github.com/lolilolicon/ffcast.git

# TODO: (+ means done.)
# xwininfo -display ${display} -- so we add an option for display
# + add support for multi-window recording, like with gimp
# + sanity: ffmpeg will quit if geometry is out of screen
# + use Corners instead of Width/Height for the sake of Border width
# + area selection, like drag a rectangle, instead of click windows (xrectsel)
# multi-head support? only if ffmpeg could record multiple screens

# {{{ defaults
PRGNAME='ffcast' PRGVER='0.1'
PRGDESC='take screencast using ffmpeg with the help of xwininfo and xrectsel'
PRGSELF=$(readlink -f "$0")
EXT='avi'
OUTPUT="${PRGNAME}.$(date +%y%m%d%H%M%S).${EXT}"
FPS='15'
PRESET='lossless_slow'
CODEC='x264'
FORMAT='h264'
GUESSFMT='1'
XRECTSEL=
BORDERLESS='1'
FFMOD='2'
DEBUG='/dev/null'
# }}}

# {{{ functions
usage () {
local ffcast=$(basename "${PRGSELF}")
cat << EOF

    % ${PRGNAME} % <${PRGVER}>
         :: ${PRGDESC}

    Usage:  ${ffcast} -b -n 3 -o /tmp/cast.mkv
            ${ffcast} -B -m -i "0x60001b 0x1c00016"
            ${ffcast} -s -f flv -c flv -o cast.flv --debug

    OPTIONS:
    -o,--output:     Output file. Supported formats: basically everything ffmpeg supports
    -s,--xrectsel)   Select capture area by mouse dragging (mimics scrot -s, but must drag)
    -S,--noxrectsel) Use xwininfo to define capture area, either by click or window IDs
    -m,--mod16       Force ffmpeg frame size to be mod 16

    -n,--winno:      Number of window(s) to be captured, use w/o -i or -f
    -i,--winid:      Window ID to capture (see xwininfo), format: "ID1 ID2 ID3" (quoted)
    -a,--fullscreen  Capture full screen, aka \`-i root\`
    -b,--borderless  Ignore borders of window(s) [default]
    -B,--border      Do not ignore borders (opposite to -b)

    -c,--codec:      Codec to use (def: '${CODEC}', use ? or list for a list)
    -f,--format:     Force format (def: '${FORMAT}', use ? or list for a list)
    -g,--guessfmt    Let ffmpeg guess format according to filename extention [default]
    -G,--noguessfmt  Do not guess format, respect default format: '${FORMAT}'
    -p,--preset:     x264 preset. (def: '${PRESET}', see /usr/share/ffmpeg/)
    -r,--rate:       Frame Rate (FPS) (def: ${FPS})

    -v,--debug       print verbose debug info to stderr
    -h,--help        Show this message

EOF
}
# tucker M N expands N to mod M
# nipper M N shrinks N to mod M
tucker () { local m=$1; shift; echo $(( $1 + ($m - ($1 % $m)) % $m )); }
nipper () { local m=$1; shift; echo $(( $1 / $m * $m )); }
min () { LC_ALL=C ; echo "$@" | tr ' ' '\n' | grep . | sort -g | head -1; }
max () { LC_ALL=C ; echo "$@" | tr ' ' '\n' | grep . | sort -g | tail -1; }
check_apps () {
    local app oops=
    for app in ffmpeg xwininfo xrectsel; do
        which "${app}" &>/dev/null || {
        echo "(EE) ${app} not found in PATH"; oops=1; }
    done
    [ "${oops}" ] && {
    echo "(EE) Required program(s) not found in PATH"; exit 1; }
}
rootwin_xy () {
    # global: defines: RLEN_X RLEN_Y
    local regex='Width: +([0-9]+).*Height: +([0-9]+)'
    local wininfo=$(LANG='' xwininfo -root)
    if [[ "$wininfo" =~ $regex ]]
    then
        RLEN_X=${BASH_REMATCH[1]}
        RLEN_Y=${BASH_REMATCH[2]}
    else
        echo "(EE) xwininfo returned wrong Data (root):"
        echo "$wininfo" ; exit 1
    fi
    echo "(DD) geometry: root: $RLEN_X x $RLEN_Y" >"${DEBUG}"
}
geo_sanity () {
    # global: LEN_X LEN_Y POS_X POS_Y RLEN_X RLEN_Y FFMOD DEBUG
    # mod FFMOD & inside screen
    LEN_X=$(tucker ${FFMOD} $LEN_X)
    LEN_Y=$(tucker ${FFMOD} $LEN_Y)
    echo "(DD) geometry: mod ${FFMOD}: $LEN_X x $LEN_Y" >"${DEBUG}"
    LEN_X=$(min $LEN_X $(nipper ${FFMOD} $(( RLEN_X - POS_X ))))
    LEN_Y=$(min $LEN_Y $(nipper ${FFMOD} $(( RLEN_Y - POS_Y ))))
    echo "(DD) geometry: in screen: $LEN_X x $LEN_Y" >"${DEBUG}"
    echo ":: Capture geometry: ${LEN_X}x${LEN_Y}+${POS_X}+${POS_Y}"
}
window_info () {
    local wininfo regex SOP_X SOP_Y DEC_W=0
    case "${WINID,,}" in
        '')
        echo ":: Click to select ${WINNO:-1} window(s) to be captured"
        for ((i=1;i<=${WINNO:-1};i++)); do
            WINIDS+=("$i")
        done
        wininfo () { LANG='' xwininfo ; } ;;
        root)
        echo ":: Fullscreen capture may take a while"
        WINIDS=($WINID)
        wininfo () { LANG='' xwininfo -root ; } ;;
        *)
        echo ":: Selected window(s): $WINID"
        WINIDS=($WINID)
        wininfo () { LANG='' xwininfo -id $WINID ; } ;;
    esac
    regex='Border width: +([0-9]+).*Corners: +\+(-?[0-9]+)\+(-?[0-9]+).* +-(-?[0-9]+)-(-?[0-9]+)'
    # support for multiple windows
    for WINID in "${WINIDS[@]}"; do
        echo -ne "\033[s:: Selecting $WINID of ${#WINIDS[@]} window(s)"
        wininfo=$(wininfo) || { echo "(WW) xwininfo error @ window $WINID"; continue; }
        if [[ "$wininfo" =~ $regex ]]
        then
            [ "$BORDERLESS" ] && DEC_W=${BASH_REMATCH[1]}
            # inside screen, they must be -ge 0 [max]
            # multiple windows, we pick the [min]
            POS_X=$(min ${POS_X} $(max 0 $(( ${BASH_REMATCH[2]} + DEC_W ))))
            POS_Y=$(min ${POS_Y} $(max 0 $(( ${BASH_REMATCH[3]} + DEC_W ))))
            SOP_X=$(min ${SOP_X} $(max 0 $(( ${BASH_REMATCH[4]} + DEC_W ))))
            SOP_Y=$(min ${SOP_Y} $(max 0 $(( ${BASH_REMATCH[5]} + DEC_W ))))
        else
            echo "(EE) xwininfo returned wrong Data:"
            echo "$wininfo" ; exit 1
        fi
        echo -ne '\033[u\033[K'
        echo "(DD) geometry: ($POS_X,$POS_Y) ($SOP_X,$SOP_Y)" >"${DEBUG}"
    done
    [ -z "$wininfo" ] && { echo "(EE) xwininfo failure"; exit 1; }
    unset wininfo
    LEN_X=$(( RLEN_X - POS_X - SOP_X ))
    LEN_Y=$(( RLEN_Y - POS_Y - SOP_Y ))
    geo_sanity
}
rectang_sel () {
    local regex='([0-9]+)x([0-9]+)\+([0-9]+)\+([0-9]+)'
    echo ":: Select area to be captured by dragging the mouse"
    local rsgeo=$(xrectsel)
    if [[ "${rsgeo}" =~ $regex ]]
    then
        LEN_X=${BASH_REMATCH[1]}
        LEN_Y=${BASH_REMATCH[2]}
        POS_X=${BASH_REMATCH[3]}
        POS_Y=${BASH_REMATCH[4]}
    else
        echo "(EE) xrectsel returned wrong Data:"
        echo "$rsgeo" ; exit 1
    fi
    geo_sanity
}
listEVcodecs () {
    echo x264
    ffmpeg -formats 2>/dev/null | \
    sed '/^ \+[D ]EV[S ][D ][T ] \+\([^ ]*\).*/!d;s//\1/'
}
valueEVcodec () {
    local evc="$1" EVC=
    [[ "${evc,,}" =~ ^\?$|^list$ ]] && { listEVcodecs; exit 0; }
    EVC=$(listEVcodecs | grep -Fxi "$evc" 2>"${DEBUG}") && CODEC="$EVC" \
    || {
    echo "(WW) ffmpeg: unsupported codec: $evc"
    echo "(WW) falling back to codec: ${CODEC}"; }
}
listEVformats () {
    ffmpeg -formats 2>/dev/null | \
    sed '/^ \+[D ]E \+\([^ ]*\).*/!d;s//\1/'
}
valueEVformat () {
    GUESSFMT=
    local evf="$1" EVF=
    [[ "${evf,,}" =~ ^\?$|^list$ ]] && { listEVformats; exit 0; }
    EVF=$(listEVformats | grep -Fxi "$evf" 2>"${DEBUG}") && FORMAT="$EVF" \
    || {
    echo "(WW) ffmpeg: unsupported format: $evf"
    echo "(WW) falling back to format: ${FORMAT}"; }
}
# }}}

# {{{ options
until [ -z "$1" ] ; do
    case "$1" in
        -h|--help)       usage ; exit 0 ;;
        -s|--xrectsel)   XRECTSEL=1 ; shift ;;
        -S|--noxrectsel) XRECTSEL=  ; shift ;;
        -a|--fullscreen) WINID="root" ; shift ;;
        -b|--borderless) BORDERLESS=1 ; shift ;;
        -B|--border)     BORDERLESS=  ; shift ;;
        -i|--winid)      WINID="$2" ; shift 2 ;;
        -n|--winno)      WINNO="$2" ; shift 2 ;;
        -m|--mod16)      FFMOD="16" ; shift ;;
        -c|--codec)      valueEVcodec "$2" ; shift 2 ;;
        -f|--format)     valueEVformat "$2" ; shift 2 ;;
        -g|--guessfmt)   GUESSFMT=1 ; shift ;;
        -G|--noguessfmt) GUESSFMT=  ; shift ;;
        -r|--rate)       FPS="$2" ; shift 2 ;;
        -p|--preset)     PRESET="$2" ; shift 2 ;;
        -o|--output)     OUTPUT="$2" ; shift 2 ;;
        -v|--debug)      DEBUG='/dev/stderr' ; shift ;;
        *)               echo "(EE) invalid option $1" ; exit 1 ;;
    esac
done
# }}}

# {{{ main
check_apps

[ -z "${DISPLAY}" ] && { echo '(EE) X not running'; exit 1; }

# is there a way to do ${OUTPUT##*.,,} ?
#( ext="${OUTPUT##*.}"; [[ "${ext,,}" =~ ^avi$|^mkv$|^mp4$ ]] ) || {
#echo "(WW) output: unsupported format"
#echo "(WW) output: falling back to ${EXT}"
#OUTPUT="${OUTPUT}.${EXT}"; }
# this block of code should be gone forever!!
# -- well, only when we can deal with format AND codec well enough?
# or develop this further to a function check_extention()?

while [ -f "${OUTPUT}" ] ; do
    echo "(WW) output: file exists: ${OUTPUT}"
    OUTPUT="${OUTPUT%.*}.${PRGNAME:-0}.${OUTPUT##*.}"
    echo "(WW) output: output name: ${OUTPUT}"
done

case "${CODEC,,}" in
    x264)
    VCODEC="libx264 -vpre main -vpre ${PRESET} -crf 0" ;;
    *)
    VCODEC="${CODEC}" ;;
esac
VCODEC="-vcodec ${VCODEC}"
[ "${GUESSFMT}" ] && FORMAT= || FORMAT="-f ${FORMAT}"
# maybe add check_extention when GUESSFMT=1?
echo "(DD) VCODEC: ${VCODEC}" >"${DEBUG}"
echo "(DD) FORMAT: ${FORMAT}" >"${DEBUG}"

rootwin_xy
if [ "${XRECTSEL}" ]; then rectang_sel; else window_info; fi

echo ":: Capture started, press [q] to finish"
# -threads 0 was in the original, but segfaults with, say -vcodec flv
ffmpeg -r ${FPS} -v 1  \
    -s ${LEN_X}x${LEN_Y} -an \
    -f x11grab -i ${DISPLAY}+${POS_X},${POS_Y} \
    ${VCODEC} ${FORMAT} "${OUTPUT}" 2>"${DEBUG}" || \
echo "(EE) ffmpeg: failed, try running with --debug"
echo ":: output: output name: ${OUTPUT}"
# }}}
# vim: fdm=marker
