#!/bin/bash
###::: take screencast using ffmpeg with the help of xwininfo
# Original: http://bbs.archlinux.org/viewtopic.php?id=85237
#           http://continuity.intelink.pl/~neuro/projects/lossless_screencast.sh
# Original Author: Copyright (c) Michal Witkowski 2009
# License: GPL v3
# Modified by: lolilolicon (and he likes to call it ffcast)
# lolilolicon <lolilolicon@gmail.com>
# git clone git://github.com/lolilolicon/ffcast.git

# TODO: (+ means done.)
# xwininfo -display ${display} -- so we add an option for display
# + add support for multi-window recording, like with gimp
# + sanity: ffmpeg will quit if geometry is out of screen
# + use Corners instead of Width/Height for the sake of Border width
# + area selection, like drag a rectangle, instead of click windows (xrectsel)
# multi-head support? only if ffmpeg could record multiple screens
# + option to limit capture duration
# should I add an option that allows user to pass options directly to ffmpeg? \
#   if I do, will I have to use eval? -- eval is dangerous

# {{{ defaults
PRGNAME='ffcast' PRGVER='0.1'
PRGDESC='take screencast using ffmpeg with the help of xwininfo and xrectsel'
PRGSELF=$(readlink -f "$0")
EXT='avi'
OUTPUT="${PRGNAME}.$(date +%y%m%d%H%M%S).${EXT}"
FPS='15'
PRESET='lossless_slow'
CODEC='x264'
FORMAT='h264'
GUESSFMT='1'
SELMODE='XWININFO'
BORDERLESS='1'
CASTSPAN=
FFMOD='2'
COLORMSG='1'
DEBUG='/dev/null'
# }}}

# {{{ functions
# {{{ help functions
# {{{ helper: printing
msg () {
    local mesg=$1; shift
    if [ $COLORMSG ]; then
        printf "\033[1;32m==> \033[1;0m\033[1;1m ${mesg}\033[1;0m\n" "$@" >&2
    else
        printf "==> ${mesg}\n" "$@" >&2
    fi
}
msg2 () {
    local mesg=$1; shift
    if [ $COLORMSG ]; then
        printf "\033[1;34m  -> \033[1;0m\033[1;1m ${mesg}\033[1;0m\n" "$@" >&2
    else
        printf "==> ${mesg}\n" "$@" >&2
    fi
}
wrn () {
    local mesg=$1; shift
    if [ $COLORMSG ]; then
        printf "\033[1;33m(WW) \033[1;0m\033[1;1m ${mesg}\033[1;0m\n" "$@" >&2
    else
        printf "(WW) ${mesg}\n" "$@" >&2
    fi
}
err () {
    local mesg=$1; shift
    if [ $COLORMSG ]; then
        printf "\033[1;31m(EE) \033[1;0m\033[1;1m ${mesg}\033[1;0m\n" "$@" >&2
    else
        printf "(EE) ${mesg}\n" "$@" >&2
    fi
}
dbg () {
    local mesg=$1; shift
    if [ $COLORMSG ]; then
        printf "\033[1;37m(DD) \033[1;0m\033[1;1m ${mesg}\033[1;0m\n" "$@" >"${DEBUG}"
    else
        printf "(DD) ${mesg}\n" "$@" >&2
    fi
}
# }}}
# {{{ usage
usage () {
local ffcast=$(basename "${PRGSELF}")
cat << EOF

    % ${PRGNAME} % <${PRGVER}>
         :: ${PRGDESC}

    Usage:  ${ffcast} -b -n 3 -o /tmp/cast.mkv
            ${ffcast} -B -m -i "0x60001b 0x1c00016"
            ${ffcast} -s -t 5:30 -f flv -c flv -o cast.flv --debug
            ${ffcast} -j '20%,20% 960,600' -r 20 -p ./custom.ffpreset -o cast.mp4

    OPTIONS:
    -o,--output:     Output /path/to/file; filename extention is important with --guessfmt
                     Output to stdout if - is used, disables --guessfmt
    -s,--xrectsel    Select capture area by mouse dragging (mimics scrot -s, but must drag)
    -w,--xwininfo    Use xwininfo to define capture area, either by click or window IDs
    -j,--xjustcap:   Specify capture area geometry within command line; no manual selection
    -m,--mod16       Force ffmpeg frame size to be mod 16

    -n,--winno:      Number of window(s) to be captured, use w/o --winid or --fullscreen
    -i,--winid:      Window ID to capture (see xwininfo), format: "ID1 ID2 ID3" (quoted)
    -a,--fullscreen  Capture full screen, aka \`-i root\`
    -b,--borderless  Ignore borders of window(s) [default]
    -B,--border      Do not ignore borders (opposite to -b)

    -c,--codec:      Codec to use (def: '${CODEC}', use ? or list for a list)
    -f,--format:     Force format (def: '${FORMAT}', use ? or list for a list)
    -g,--guessfmt    Let ffmpeg guess format according to filename extention [default]
    -G,--noguessfmt  Do not guess format, respect default format: '${FORMAT}'
    -p,--preset:     x264 preset. (def: '${PRESET}', use ? or list for a list)
    -r,--rate:       Frame Rate (FPS) (def: ${FPS})
    -t,--duration:   Restrict cast video duration in seconds; alternatively hh:mm:ss[.xxx]

    -v,--debug       Print verbose debug info to stderr
       --nocolor     Disable colors in messages
    -h,--help        Show this message

EOF
}
# }}}
# {{{ helper: maths
# tucker M N expands N to mod M
# nipper M N shrinks N to mod M
tucker () { local m=$1; shift; echo $(( $1 + ($m - ($1 % $m)) % $m )); }
nipper () { local m=$1; shift; echo $(( $1 / $m * $m )); }
min () { LC_ALL=C ; echo "$@" | tr ' ' '\n' | grep . | sort -g | head -1; }
max () { LC_ALL=C ; echo "$@" | tr ' ' '\n' | grep . | sort -g | tail -1; }
hhmmss2sec () {
    # ffmpeg -t option does support hh:mm:ss[.xxx], but not mm:ss -- too dumb
    # so let's convert hh:mm:ss to seconds so ffmpeg can understand
    local hms="$1" smh hh mm ss sech secm secs
    smh=($(awk -F: '{ for (i = NF; i > 0 ; --i ) print $i }' <<< "${hms}"))
    ss="${smh[0]:-00}"  ;   secs="${ss}"
    mm="${smh[1]:-00}"  ;   secm=$(bc <<< "${mm} * 60")
    hh="${smh[2]:-00}"  ;   sech=$(bc <<< "${hh} * 3600")
    sec=$(bc <<< "scale=2 ; ${secs} + ${secm} + ${sech}")
    echo "${sec}"
}
sec2hhmmss () {
    # we'd like to display time in hh:mm:ss.xx format, it's more readable
    local sec="$1" hh mm ss
    hh=$(printf "%02d" $(bc <<< "${sec} / 3600"))
    mm=$(printf "%02d" $(bc <<< "$(bc <<< "${sec} / 60") % 60"))
    ss=$(printf "%05.2f" $(bc <<< "${sec} % 60"))
    echo "${hh}:${mm}:${ss}"
}
percen2len () {
    local val="$1" all="$2"
    [[ "$val" =~ %$ ]] && { bc <<< "${val%\%} * $all / 100"; return; }
    echo "$val"
}
# }}}
# }}}
# {{{ core functions
# {{{ checker: apps
check_apps () {
    local app oops=
    for app in ffmpeg xwininfo xrectsel bc; do
        which "${app}" &>/dev/null || {
        err "${app} not found in PATH"; oops=1; }
    done
    [ "${oops}" ] && {
    err "Required program(s) not found in PATH"; exit 1; }
}
# }}}
# {{{ checker: display
check_display () {
    [ -z "${DISPLAY}" ] && { err "X not running"; exit 1; }
}
# }}}
# {{{ checker: outfile
check_outfile () {
    # is there a way to do ${OUTPUT##*.,,} ?
    #( ext="${OUTPUT##*.}"; [[ "${ext,,}" =~ ^avi$|^mkv$|^mp4$ ]] ) || {
    #wrn "output: unsupported format"
    #wrn "output: falling back to ${EXT}"
    #OUTPUT="${OUTPUT}.${EXT}"; }
    # this block of code should be gone forever!!
    # -- well, only when we can deal with format AND codec well enough?
    # or develop this further to a function check_extention()?
    [ "${OUTPUT}" == '-' ] && { GUESSFMT= ; return; }
    while [ -f "${OUTPUT}" ] ; do
        wrn "output: file exists: ${OUTPUT}"
        OUTPUT="${OUTPUT%.*}.${PRGNAME:-0}.${OUTPUT##*.}"
        wrn "output: output name: ${OUTPUT}"
    done
}
# }}}
# {{{ checker: geometry
rootwin_xy () {
    # global: defines: RLEN_X RLEN_Y
    local regex='Width: +([0-9]+).*Height: +([0-9]+)'
    local wininfo=$(LANG='' xwininfo -root 2>"${DEBUG}")
    if [[ "$wininfo" =~ $regex ]]
    then
        RLEN_X=${BASH_REMATCH[1]}
        RLEN_Y=${BASH_REMATCH[2]}
    else
        err "xwininfo returned wrong Data (root):"
        echo "$wininfo" ; exit 1
    fi
    dbg "geometry: root: $RLEN_X x $RLEN_Y"
}
geo_sanity () {
    # global: LEN_X LEN_Y POS_X POS_Y RLEN_X RLEN_Y FFMOD DEBUG
    # mod FFMOD & inside screen
    LEN_X=$(tucker ${FFMOD} $LEN_X)
    LEN_Y=$(tucker ${FFMOD} $LEN_Y)
    dbg "geometry: mod ${FFMOD}: $LEN_X x $LEN_Y"
    LEN_X=$(min $LEN_X $(nipper ${FFMOD} $(( RLEN_X - POS_X ))))
    LEN_Y=$(min $LEN_Y $(nipper ${FFMOD} $(( RLEN_Y - POS_Y ))))
    dbg "geometry: in screen: $LEN_X x $LEN_Y"
    msg "Capture geometry: ${LEN_X}x${LEN_Y}+${POS_X}+${POS_Y}"
}
# }}}
# {{{ define capture area with xwininfo
window_info () {
    local wininfo regex SOP_X SOP_Y DEC_W=0
    case "${WINID,,}" in
        '')
        msg "Click to select ${WINNO:-1} window(s) to be captured"
        for ((i=1;i<=${WINNO:-1};i++)); do
            WINIDS+=("$i")
        done
        wininfo () { LANG='' xwininfo ; } ;;
        root)
        msg "Fullscreen capture"
        WINIDS=($WINID)
        wininfo () { LANG='' xwininfo -root ; } ;;
        *)
        msg "Selected window(s): $WINID"
        WINIDS=($WINID)
        wininfo () { LANG='' xwininfo -id $WINID ; } ;;
    esac
    regex='Border width: +([0-9]+).*Corners: +\+(-?[0-9]+)\+(-?[0-9]+).* +-(-?[0-9]+)-(-?[0-9]+)'
    # support for multiple windows
    for WINID in "${WINIDS[@]}"; do
        #echo -ne '\033[s'
        msg2 "Selecting $WINID of ${#WINIDS[@]} window(s)"
        wininfo=$(wininfo 2>"${DEBUG}") || { wrn "xwininfo error @ window $WINID"; continue; }
        if [[ "$wininfo" =~ $regex ]]
        then
            [ "$BORDERLESS" ] && DEC_W=${BASH_REMATCH[1]}
            # inside screen, they must be -ge 0 [max]
            # multiple windows, we pick the [min]
            POS_X=$(min ${POS_X} $(max 0 $(( ${BASH_REMATCH[2]} + DEC_W ))))
            POS_Y=$(min ${POS_Y} $(max 0 $(( ${BASH_REMATCH[3]} + DEC_W ))))
            SOP_X=$(min ${SOP_X} $(max 0 $(( ${BASH_REMATCH[4]} + DEC_W ))))
            SOP_Y=$(min ${SOP_Y} $(max 0 $(( ${BASH_REMATCH[5]} + DEC_W ))))
        else
            err "xwininfo returned wrong Data:"
            echo "$wininfo" ; exit 1
        fi
        #echo -ne '\033[u\033[K'
        #echo -ne '\033[A\033[K'
        dbg "geometry: ($POS_X,$POS_Y) ($SOP_X,$SOP_Y)"
    done
    [ -z "$wininfo" ] && { err "xwininfo failure"; exit 1; }
    unset wininfo
    LEN_X=$(( RLEN_X - POS_X - SOP_X ))
    LEN_Y=$(( RLEN_Y - POS_Y - SOP_Y ))
}
# }}}
# {{{ define capture area with xrectsel
rectang_sel () {
    local regex='([0-9]+)x([0-9]+)\+([0-9]+)\+([0-9]+)'
    msg "Select screen area to be captured by mouse drag"
    msg2 "Drag mouse with button one pressed"
    msg2 "Press any key on keyboard to abort"
    local rsgeo=$(xrectsel)
    if [[ "${rsgeo}" =~ $regex ]]
    then
        LEN_X=${BASH_REMATCH[1]}
        LEN_Y=${BASH_REMATCH[2]}
        POS_X=${BASH_REMATCH[3]}
        POS_Y=${BASH_REMATCH[4]}
    else
        err "xrectsel returned wrong Data:"
        echo "$rsgeo" ; exit 1
    fi
}
# }}}
# {{{ define capture area with prophecy
g_translate () {
    msg "Validating user-defined capture geometry"
    local geo="$1" regex i matched

    # '(x1,y1) (x2, y2)' or 'x1%,y1% x2,y2' and the likes. [diagonal]
    regex[0]='^[^0-9]*([0-9]+%?), *([0-9]+%?)[^0-9]+([0-9]+%?), *([0-9]+%?)[^0-9]*$'
    gcalc_0 () {
        local x1 y1 x2 y2
        x1=$(percen2len ${BASH_REMATCH[1]} $RLEN_X)
        y1=$(percen2len ${BASH_REMATCH[2]} $RLEN_Y)
        x2=$(percen2len ${BASH_REMATCH[3]} $RLEN_X)
        y2=$(percen2len ${BASH_REMATCH[4]} $RLEN_Y)
        POS_X=$(min $x1 $x2)
        POS_Y=$(min $y1 $y2)
        LEN_X=$(max $(( x1 - x2 )) $(( x2 - x1 )))
        LEN_Y=$(max $(( y1 - y2 )) $(( y2 - y1 )))
    }

    # about to add gravity stuff and human language...?
    # (yes, i kinda admire date -d)

    for ((i=0;i<${#regex[@]};i++)); do
        if [[ "${geo}" =~ ${regex[$i]} ]];
        then
            matched=1
            msg2 "Valid geometry ${geo//%/%%}"
            gcalc_$i
            break
        fi
    done
    [ "${matched}" ] || { err "Invalid geometry: ${geo//%/%%}"; exit 1; }

    for ((i=0;i<${#regex[@]};i++)); do
        unset gcalc_$i
    done
}
# }}}
# {{{ let you select area
let_you_select () {
    rootwin_xy
    case "${SELMODE}" in
        XWININFO) window_info ;;
        XRECTSEL) rectang_sel ;;
        XJUSTCAP) g_translate "${SELGEOM}" ;;
    esac
    geo_sanity
}
# }}}
# {{{ checker: codecs
listx264prst () {
    local PREFIX=$(ffmpeg -version 2>&1 | sed '/.*configuration:.*--prefix=\([^ ]*\).*/!d;s//\1/')
    PREFIX="${PREFIX:-/usr}"
    { ls -1 "${PREFIX}"/share/ffmpeg
      [ -d "${HOME}"/.ffmpeg ] && ls -1 "${HOME}"/.ffmpeg; } | sed 's/libx264-\(.*\)\.ffpreset/\1/'
    [ -f "$1" ] && echo "$1"
}
valuex264prst () {
    local prst="$1" PRST=
    [[ "${prst,,}" =~ ^\?$|^list$ ]] && { listx264prst "$prst" ; exit 0; }
    PRST=$(listx264prst "$prst" | grep -m1 -Fxi "$prst" 2>"${DEBUG}") && PRESET="$PRST" \
    || {
    wrn "ffmpeg: x264 preset not found: $prst"
    wrn "falling back to preset: ${PRESET}"; }
}
listEVcodecs () {
    echo x264
    ffmpeg -formats 2>/dev/null | \
    sed '/^ \+[D ]EV[S ][D ][T ] \+\([^ ]*\).*/!d;s//\1/'
}
valueEVcodec () {
    local evc="$1" EVC=
    [[ "${evc,,}" =~ ^\?$|^list$ ]] && { listEVcodecs; exit 0; }
    EVC=$(listEVcodecs | grep -Fxi "$evc" 2>"${DEBUG}") && CODEC="$EVC" \
    || {
    wrn "ffmpeg: unsupported codec: $evc"
    wrn "falling back to codec: ${CODEC}"; }
}
listEVformats () {
    ffmpeg -formats 2>/dev/null | \
    sed '/^ \+[D ]E \+\([^ ]*\).*/!d;s//\1/'
}
valueEVformat () {
    GUESSFMT=
    local evf="$1" EVF=
    [[ "${evf,,}" =~ ^\?$|^list$ ]] && { listEVformats; exit 0; }
    EVF=$(listEVformats | grep -Fxi "$evf" 2>"${DEBUG}") && FORMAT="$EVF" \
    || {
    wrn "ffmpeg: unsupported format: $evf"
    wrn "falling back to format: ${FORMAT}"; }
}
check_vidcodec () {
    case "${CODEC,,}" in
        x264)
        VCODEC="libx264 -vpre main -vpre ${PRESET} -crf 0" ;;
        gif)
        VCODEC="rawvideo -pix_fmt rgb24 -loop_output 0" #XXX ffmpeg sucks at gif
        FORMAT="gif" ;;
        *)
        VCODEC="${CODEC}" ;;
    esac
    case "${FORMAT,,}" in
        gif)
        wrn "ffmpeg: -vcodec gif is broken, using rawvideo"
        wrn "ffmpeg: gif output can be HUGE [uncompressed]" #XXX really?
        VCODEC="rawvideo -pix_fmt rgb24 -loop_output 0" #XXX ffmpeg sucks at gif
        ;;
        *)
        FORMAT="${FORMAT}"
    esac
    VCODEC="-vcodec ${VCODEC}"
    [ "${GUESSFMT}" ] && FORMAT= || FORMAT="-f ${FORMAT}"
    # maybe add check_extention when GUESSFMT=1?
    dbg "VCODEC: ${VCODEC}"
    dbg "FORMAT: ${FORMAT}"
}
# }}}
# {{{ checker: duration
check_castspan () {
    [ "${CASTSPAN}" ] || return
    CASTSPAN=$(hhmmss2sec ${CASTSPAN})
    msg "Capture duration limited to [$(sec2hhmmss ${CASTSPAN})]"
    CASTSPAN="-t ${CASTSPAN}"
}
# }}}
# {{{ let me capture that with ffmpeg
let_me_capture () {
    msg "Capture started, press [q] to finish"
    # -threads 0 was in the original, but segfaults with, say -vcodec flv
    ffmpeg -r ${FPS} -v 1  \
        -s ${LEN_X}x${LEN_Y} -an \
        -f x11grab -i ${DISPLAY}+${POS_X},${POS_Y} \
        ${VCODEC} ${FORMAT} ${CASTSPAN} \
        "${OUTPUT}" 2>"${DEBUG}" || \
    err "ffmpeg: failed, try running with --debug"
    msg "Output filename: ${OUTPUT}"
}
# }}}
# }}}
# }}}

# {{{ options
# left: d e k l q u x y z
until [ -z "$1" ] ; do
    case "$1" in
        -h|--help)       usage ; exit 0 ;;
        -s|--xrectsel)   SELMODE='XRECTSEL' ; shift ;;
        -w|--xwininfo)   SELMODE='XWININFO' ; shift ;;
        -j|--xjustcap)   SELMODE='XJUSTCAP' ; SELGEOM="$2" ; shift 2 ;;
        -a|--fullscreen) WINID="root" ; shift ;;
        -b|--borderless) BORDERLESS=1 ; shift ;;
        -B|--border)     BORDERLESS=  ; shift ;;
        -i|--winid)      WINID="$2" ; shift 2 ;;
        -n|--winno)      WINNO="$2" ; shift 2 ;;
        -m|--mod16)      FFMOD="16" ; shift ;;
        -t|--duration)   CASTSPAN="$2" ; shift 2 ;;
        -c|--codec)      valueEVcodec "$2" ; shift 2 ;;
        -f|--format)     valueEVformat "$2" ; shift 2 ;;
        -g|--guessfmt)   GUESSFMT=1 ; shift ;;
        -G|--noguessfmt) GUESSFMT=  ; shift ;;
        -r|--rate)       FPS="$2" ; shift 2 ;;
        -p|--preset)     valuex264prst "$2" ; shift 2 ;;
        -o|--output)     OUTPUT="$2" ; shift 2 ;;
        -v|--debug)      DEBUG='/dev/stderr' ; shift ;;
           --nocolor)    COLORMSG= ; shift ;;
        *)               err "invalid option $1" ; exit 1 ;;
    esac
done
# }}}

# {{{ main
check_apps
check_display
check_outfile
let_you_select
check_vidcodec
check_castspan
let_me_capture
# }}}
# vim: fdm=marker
